{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-prisma-schema",
  "type": "registry:hook",
  "title": "usePrismaSchema",
  "description": "",
  "dependencies": [
    "@tanstack/react-query",
    "@xyflow/react"
  ],
  "registryDependencies": [
    "https://futurjs.vercel.app/r/prisma-actions.json"
  ],
  "files": [
    {
      "path": "src/shared/prisma/hooks/use-prisma-schema.tsx",
      "content": "\"use client\";\n\nimport { Prisma } from \"@/generated/prisma\";\nimport { Edge, Node } from \"@xyflow/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getPrismaSchema } from \"@/shared/prisma/actions/prisma-actions\";\nimport z, { ZodEnum, ZodType } from \"zod/v4\";\n\nexport type FieldMeta = {\n  enumProps: Prisma.DMMF.Datamodel[\"enums\"][number];\n  description: string;\n  label: string;\n  placeholder: string;\n};\nexport type FormMeta = {};\nexport type EnumMeta = {};\n\nexport type FormModel = {\n  name: string;\n  fields: FormModelField[];\n  meta: Partial<FormMeta>;\n  zodType: z.ZodObject<any>;\n};\n\nexport type FormModelField = {\n  props: Prisma.DMMF.Field;\n  zodType: ZodType<any, any, any>;\n  meta?: Partial<FieldMeta>;\n};\n\nexport type FormEnum = {\n  name: string;\n  props: Prisma.DMMF.Datamodel[\"enums\"][number];\n  zodType: ZodEnum<any>;\n  meta?: Partial<EnumMeta>;\n};\n\nexport type PrismaForm = {\n  models: FormModel[];\n  enums: FormEnum[];\n};\n\nexport type PrismaSchema = {\n  datamodel: Prisma.DMMF.Datamodel;\n  xyflow: {\n    nodes: Node[];\n    edges: Edge[];\n  };\n  form: PrismaForm;\n};\n\nexport function datamodelToPrismaFormModel(\n  datamodel: Prisma.DMMF.Datamodel,\n  enums: FormEnum[]\n): FormModel[] {\n  const zodfields: Record<string, z.ZodType<any, any, any>> = {};\n  const models = datamodel.models.map((model) => {\n    console.log(\"model:\", model);\n\n    return {\n      name: model.name,\n      meta: {},\n      fields: model.fields.map((field) => {\n        console.log(\"  field:\", field.name);\n        zodfields[field.name] = prismaFieldToZodType(field, enums);\n        return {\n          props: field,\n          zodType: zodfields[field.name],\n          meta: {\n            enumProps:\n              field.kind === \"enum\"\n                ? enums.find((e) => e.name === field.type)?.props\n                : undefined,\n          },\n        };\n      }),\n      zodType: z.object(zodfields),\n    };\n  });\n  console.log(\"==FINISH==\");\n\n  return models;\n}\n\nfunction prismaFieldToZodType(\n  field: Prisma.DMMF.Field,\n  enums: FormEnum[]\n): ZodType<any, any, any> {\n  // BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\n  const scalarTypes = new Map<string, ZodType<any, any, any>>();\n  scalarTypes.set(\"BigInt\", z.bigint());\n  scalarTypes.set(\"Boolean\", z.boolean());\n  scalarTypes.set(\"Bytes\", z.instanceof(Buffer));\n  scalarTypes.set(\"DateTime\", z.date());\n  scalarTypes.set(\n    \"Decimal\",\n    z.number().refine((val) => !isNaN(val), {\n      message: \"Invalid decimal value\",\n    })\n  );\n  scalarTypes.set(\n    \"Float\",\n    z.number().refine((val) => !isNaN(val), {\n      message: \"Invalid float value\",\n    })\n  );\n  scalarTypes.set(\n    \"Int\",\n    z\n      .number()\n      .int()\n      .refine((val) => !isNaN(val), {\n        message: \"Invalid integer value\",\n      })\n  );\n  scalarTypes.set(\"JSON\", z.any());\n  scalarTypes.set(\"String\", z.string());\n  const type =\n    scalarTypes.get(field.type)?.clone() ||\n    enums.find((e) => e.name === field.type)?.zodType ||\n    z.any();\n  if (field.isList) {\n    return z.array(type);\n  }\n  if (field.isRequired) {\n    return type;\n  }\n  return type.optional();\n}\n\nexport const defaultPrismaSchema: PrismaSchema = {\n  datamodel: {\n    models: [],\n    enums: [],\n    indexes: [],\n    types: [],\n  },\n  xyflow: {\n    nodes: [],\n    edges: [],\n  },\n  form: {\n    models: [],\n    enums: [],\n  },\n};\n\nexport function usePrismaSchema() {\n  const { data, isLoading } = useQuery({\n    queryKey: [\"prisma-schema\"],\n    queryFn: async () => {\n      const datamodel = await getPrismaSchema();\n      const schema: PrismaSchema = {\n        datamodel,\n        xyflow: datamodelToXyflow(datamodel),\n        form: datamodelToPrismaForm(datamodel),\n      };\n      return schema;\n    },\n    // refetchOnWindowFocus: false,\n    // refetchOnReconnect: false,\n  });\n  if (!data)\n    return {\n      isLoading,\n      data: defaultPrismaSchema,\n    };\n  return {\n    isLoading,\n    data,\n  };\n}\n\nusePrismaSchema.registryDependencies = [\"prisma-actions\"];\nusePrismaSchema.dependencies = [\"@tanstack/react-query\", \"@xyflow/react\"];\n\nfunction getStableColor(modelName: string): string {\n  const hash = [...modelName].reduce((acc, c) => acc + c.charCodeAt(0), 0);\n  const hue = hash % 360;\n  return `hsl(${hue}, 70%, 60%)`;\n}\n\nfunction datamodelToXyflow(datamodel: Prisma.DMMF.Datamodel): {\n  nodes: Node[];\n  edges: Edge[];\n} {\n  const modelColorMap = new Map<string, string>();\n  const numColumns = 6;\n  const columnWidth = 300;\n  const columnHeights = new Array(numColumns).fill(100); // start y=100 pour chaque colonne\n\n  const nodes: Node[] = datamodel.models.map((model, i) => {\n    const height = model.fields.length * 30 + 100;\n\n    // Trouver la colonne la moins haute\n    const minCol = columnHeights.indexOf(Math.min(...columnHeights));\n    const x = minCol * columnWidth;\n    const y = columnHeights[minCol];\n\n    columnHeights[minCol] += height + 50; // 50px de marge verticale\n\n    const color = getStableColor(model.name);\n    modelColorMap.set(model.name, color);\n\n    return {\n      id: model.name,\n      type: \"tableNode\",\n      position: { x, y },\n      data: {\n        label: model.name,\n        color,\n        fields: model.fields.map((field) => ({\n          name: field.name,\n          type: field.type,\n          isPrimary: field.isId,\n          isForeign: field.isReadOnly,\n          meta: field,\n        })),\n      },\n    };\n  });\n\n  const edges: Edge[] = datamodel.models.flatMap((model) => {\n    return model.fields\n      .filter(\n        (field) =>\n          field.relationName &&\n          field?.relationFromFields?.length &&\n          field?.relationToFields?.length\n      )\n      .map((field) => {\n        return {\n          id: `${field.relationName}`,\n          source: field.type,\n          target: model.name,\n          sourceHandle: field?.relationToFields?.at(0),\n          targetHandle: field?.relationFromFields?.at(0),\n          animated: true,\n          // style: {\n          //   stroke: modelColorMap.get(model.name) || \"#999\",\n          // },\n        };\n      });\n  });\n\n  return { nodes, edges };\n}\n\nfunction datamodelToPrismaForm(datamodel: Prisma.DMMF.Datamodel): PrismaForm {\n  const enums = datamodelToPrismaFormEnums(datamodel);\n  return {\n    enums,\n    models: datamodelToPrismaFormModel(datamodel, enums),\n  };\n}\n\nfunction datamodelToPrismaFormEnums(\n  datamodel: Prisma.DMMF.Datamodel\n): FormEnum[] {\n  return datamodel.enums.map((enumItem) => {\n    return {\n      name: enumItem.name,\n      props: enumItem,\n      zodType: z.enum(\n        enumItem.values.map((value) => value.name) as [string, ...string[]]\n      ),\n      meta: {},\n    };\n  });\n}\n",
      "type": "registry:hook",
      "target": "shared/prisma/hooks/use-prisma-schema.tsx"
    }
  ]
}