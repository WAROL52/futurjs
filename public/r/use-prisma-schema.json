{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-prisma-schema",
  "type": "registry:hook",
  "title": "usePrismaSchema",
  "description": "",
  "dependencies": [
    "@tanstack/react-query",
    "@xyflow/react"
  ],
  "registryDependencies": [
    "https://futurjs.vercel.app/r/prisma-actions.json"
  ],
  "files": [
    {
      "path": "src/shared/prisma/hooks/use-prisma-schema.tsx",
      "content": "\"use client\";\n\nimport { Prisma } from \"@/generated/prisma\";\nimport { Edge, Node } from \"@xyflow/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getPrismaSchema } from \"@/shared/prisma/actions/prisma-actions\";\nimport z, { ZodEnum, ZodType } from \"zod/v4\";\n\nexport type FieldMeta = {\n  enumProps: Prisma.DMMF.Datamodel[\"enums\"][number];\n  description: string;\n  label: string;\n  placeholder: string;\n  allowDuplicates?: boolean;\n  maxItems?: number;\n};\nexport type FormMeta = {};\nexport type EnumMeta = {};\n\nexport type FormModel = {\n  name: string;\n  fields: FormModelField[];\n  meta: Partial<FormMeta>;\n  zodType: z.ZodObject<any>;\n};\nexport type RelationType =\n  | \"oneToOne\"\n  | \"oneToMany\"\n  | \"manyToOne\"\n  | \"manyToMany\";\nexport type FormModelField = {\n  props: Prisma.DMMF.Field;\n  zodType: ZodType<any, any, any>;\n  meta?: Partial<FieldMeta>;\n  relationType: RelationType | null;\n};\n\nexport type FormEnum = {\n  name: string;\n  props: Prisma.DMMF.Datamodel[\"enums\"][number];\n  zodType: ZodEnum<any>;\n  meta?: Partial<EnumMeta>;\n};\n\nexport type PrismaForm = {\n  models: FormModel[];\n  enums: FormEnum[];\n};\n\nexport type PrismaSchema = {\n  datamodel: Prisma.DMMF.Datamodel;\n  xyflow: {\n    nodes: Node[];\n    edges: Edge[];\n  };\n  form: PrismaForm;\n};\n\nexport function datamodelToPrismaFormModel(\n  datamodel: Prisma.DMMF.Datamodel,\n  enums: FormEnum[]\n): FormModel[] {\n  const models = datamodel.models.map((model) => {\n    const zodfields: Record<string, z.ZodType<any, any, any>> = {};\n    const fields = model.fields\n      .map((field) => {\n        if (field.isId) return null;\n        if (field.isReadOnly) return null;\n        if (field.isUpdatedAt) return null;\n        if (field.hasDefaultValue) {\n          if (typeof field.default === \"object\" && \"name\" in field.default) {\n            if (\n              field.default.name === \"now\" ||\n              field.default.name === \"cuid\" ||\n              field.default.name === \"uuid\" ||\n              field.default.name === \"autoincrement\" ||\n              field.default.name === \"updatedAt\"\n            ) {\n              return null; // Skip rendering if default value is now, cuid, or uuid\n            }\n          }\n        }\n        if (field.isList && field.kind === \"object\") {\n          const modelTarget = datamodel.models.find(\n            (m) => m.name === field.type\n          );\n          if (!modelTarget) return null;\n          const fieldTarget = modelTarget.fields.find(\n            (f) => f.relationName === field.relationName\n          );\n          if (!fieldTarget) return null;\n          if (!fieldTarget.isList) return null;\n        } else if (\n          field.kind === \"object\" &&\n          !field.relationToFields?.length &&\n          !field.relationFromFields?.length\n        )\n          return null;\n        const relationType = getRelationType(datamodel.models, field);\n        zodfields[field.name] = prismaFieldToZodType(\n          datamodel.models,\n          field,\n          enums,\n          relationType\n        );\n        return {\n          props: field,\n          zodType: zodfields[field.name],\n          relationType,\n          meta: {\n            enumProps:\n              field.kind === \"enum\"\n                ? enums.find((e) => e.name === field.type)?.props\n                : undefined,\n          },\n        } as FormModelField;\n      })\n      .filter(Boolean) as FormModelField[]; // Filter out null fields\n    console.log(model.name, zodfields);\n\n    return {\n      name: model.name,\n      meta: {},\n      fields,\n      // Filter out empty fields\n      zodType: z.object(zodfields),\n    };\n  });\n\n  return models;\n}\nfunction getRelationType(\n  models: Prisma.DMMF.Datamodel[\"models\"],\n  field: Prisma.DMMF.Field\n): RelationType | null {\n  if (field.kind !== \"object\") return null;\n  const model = models.find((m) => m.name === field.type);\n  if (!model) return null;\n  const relationField = model.fields.find(\n    (f) => f.relationName === field.relationName\n  );\n  if (!relationField) return null;\n  if (relationField.isList && field.isList) return \"manyToMany\";\n  if (relationField.isList && !field.isList) return \"oneToMany\";\n  if (!relationField.isList && field.isList) return \"manyToOne\";\n  if (!relationField.isList && !field.isList) return \"oneToOne\";\n  return null;\n}\n\nconst scalarTypes = new Map<string, ZodType<any, any, any>>();\nscalarTypes.set(\"BigInt\", z.bigint());\nscalarTypes.set(\"Boolean\", z.boolean());\nscalarTypes.set(\"Bytes\", z.instanceof(Buffer));\nscalarTypes.set(\"DateTime\", z.date());\nscalarTypes.set(\n  \"Decimal\",\n  z.number().refine((val) => !isNaN(val), {\n    message: \"Invalid decimal value\",\n  })\n);\nscalarTypes.set(\n  \"Float\",\n  z.number().refine((val) => !isNaN(val), {\n    message: \"Invalid float value\",\n  })\n);\nscalarTypes.set(\n  \"Int\",\n  z\n    .number()\n    .int()\n    .refine((val) => !isNaN(val), {\n      message: \"Invalid integer value\",\n    })\n);\nscalarTypes.set(\"JSON\", z.any());\nscalarTypes.set(\"String\", z.string());\n\nfunction getZodType(\n  models: Prisma.DMMF.Datamodel[\"models\"],\n  field: Prisma.DMMF.Field,\n  enums: FormEnum[],\n  relationType: RelationType | null\n): ZodType<any, any, any> {\n  // BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\n  let type = scalarTypes.get(field.type);\n  if (type) return type.clone();\n  type = enums.find((e) => e.name === field.type)?.zodType;\n  if (type) return type.clone();\n  if (field.kind === \"object\") {\n    const model = models.find((m) => m.name === field.type);\n    if (!model) return z.any();\n    const fieldIdName = model.fields.find((f) => f.isId);\n    if (!fieldIdName) return z.any();\n    if (relationType === \"oneToMany\") {\n      type = z\n        .object({\n          connect: z.object({ [field.relationToFields![0]]: z.string() }),\n        })\n        .or(z.object({ create: z.any() }));\n      if (field.isRequired) return type;\n      return type.optional();\n    }\n    if (relationType === \"manyToOne\") {\n      return z\n        .object({\n          connect: z.array(z.object({ [fieldIdName.name]: z.string() })),\n        })\n        .or(z.object({ create: z.array(z.any()) }))\n        .optional();\n    }\n    if (relationType === \"manyToMany\") {\n      return z\n        .object({\n          connect: z.array(z.object({ [fieldIdName.name]: z.string() })),\n        })\n        .or(z.object({ create: z.array(z.any()) }))\n        .optional();\n    }\n    if (relationType === \"oneToOne\") {\n      type = z\n        .object({\n          connect: z.object({ [field.relationToFields![0]]: z.string() }),\n        })\n        .or(z.object({ create: z.array(z.any()) }));\n      if (field.isRequired) return type;\n      return type.optional();\n    }\n  }\n  return z.any();\n}\n\nfunction prismaFieldToZodType(\n  models: Prisma.DMMF.Datamodel[\"models\"],\n  field: Prisma.DMMF.Field,\n  enums: FormEnum[],\n  relationType: RelationType | null\n): ZodType<any, any, any> {\n  // BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\n  const type = getZodType(models, field, enums, relationType);\n  if (relationType) return type;\n  if (field.isList) {\n    return z.array(type).default([]);\n  }\n  if (field.isRequired) {\n    return type;\n  }\n  return type.optional();\n}\n\nexport const defaultPrismaSchema: PrismaSchema = {\n  datamodel: {\n    models: [],\n    enums: [],\n    indexes: [],\n    types: [],\n  },\n  xyflow: {\n    nodes: [],\n    edges: [],\n  },\n  form: {\n    models: [],\n    enums: [],\n  },\n};\n\nexport function usePrismaSchema() {\n  const { data, isLoading } = useQuery({\n    queryKey: [\"prisma-schema\"],\n    queryFn: async () => {\n      const datamodel = await getPrismaSchema();\n      const schema: PrismaSchema = {\n        datamodel,\n        xyflow: datamodelToXyflow(datamodel),\n        form: datamodelToPrismaForm(datamodel),\n      };\n      return schema;\n    },\n    // refetchOnWindowFocus: false,\n    // refetchOnReconnect: false,\n  });\n  if (!data)\n    return {\n      isLoading,\n      data: defaultPrismaSchema,\n    };\n  return {\n    isLoading,\n    data,\n  };\n}\n\nusePrismaSchema.registryDependencies = [\"prisma-actions\"];\nusePrismaSchema.dependencies = [\"@tanstack/react-query\", \"@xyflow/react\"];\n\nfunction getStableColor(modelName: string): string {\n  const hash = [...modelName].reduce((acc, c) => acc + c.charCodeAt(0), 0);\n  const hue = hash % 360;\n  return `hsl(${hue}, 70%, 60%)`;\n}\n\nexport function datamodelToXyflow(datamodel: Prisma.DMMF.Datamodel): {\n  nodes: Node[];\n  edges: Edge[];\n} {\n  const modelColorMap = new Map<string, string>();\n  const numColumns = 6;\n  const columnWidth = 300;\n  const columnHeights = new Array(numColumns).fill(100); // start y=100 pour chaque colonne\n\n  const nodes: Node[] = datamodel.models.map((model, i) => {\n    const height = model.fields.length * 30 + 100;\n\n    // Trouver la colonne la moins haute\n    const minCol = columnHeights.indexOf(Math.min(...columnHeights));\n    const x = minCol * columnWidth;\n    const y = columnHeights[minCol];\n\n    columnHeights[minCol] += height + 50; // 50px de marge verticale\n\n    const color = getStableColor(model.name);\n    modelColorMap.set(model.name, color);\n\n    return {\n      id: model.name,\n      type: \"tableNode\",\n      position: { x, y },\n      data: {\n        label: model.name,\n        color,\n        fields: model.fields.map((field) => ({\n          name: field.name,\n          type: field.type,\n          isPrimary: field.isId,\n          isForeign: field.isReadOnly,\n          meta: field,\n        })),\n      },\n    };\n  });\n\n  const edges: Edge[] = datamodel.models.flatMap((model) => {\n    return model.fields\n      .filter(\n        (field) =>\n          field.relationName &&\n          field?.relationFromFields?.length &&\n          field?.relationToFields?.length\n      )\n      .map((field) => {\n        return {\n          id: `${field.relationName}`,\n          source: field.type,\n          target: model.name,\n          sourceHandle: field?.relationToFields?.at(0),\n          targetHandle: field?.relationFromFields?.at(0),\n          animated: true,\n          // style: {\n          //   stroke: modelColorMap.get(model.name) || \"#999\",\n          // },\n        };\n      });\n  });\n\n  return { nodes, edges };\n}\n\nexport function datamodelToPrismaForm(\n  datamodel: Prisma.DMMF.Datamodel\n): PrismaForm {\n  const enums = datamodelToPrismaFormEnums(datamodel);\n  return {\n    enums,\n    models: datamodelToPrismaFormModel(datamodel, enums),\n  };\n}\n\nexport function datamodelToPrismaFormEnums(\n  datamodel: Prisma.DMMF.Datamodel\n): FormEnum[] {\n  return datamodel.enums.map((enumItem) => {\n    return {\n      name: enumItem.name,\n      props: enumItem,\n      zodType: z.enum(\n        enumItem.values.map((value) => value.name) as [string, ...string[]]\n      ),\n      meta: {},\n    };\n  });\n}\n",
      "type": "registry:hook",
      "target": "shared/prisma/hooks/use-prisma-schema.tsx"
    }
  ]
}